#include <TXLib.h>

const int INFINITY_ROOTS = -1; // варианты количества корней
const int ZERO_ROOTS = 0;
const int ONE_ROOT = 1;
const int TWO_ROOTS = 2;

const int BIGGER_1 = 1; // сравнение чисел
const int EQUAL = 0;
const int BIGGER_2 = -1;

const char CONFIRM = '1'; // подтверждение

const char SOLVER_BUTTON = '1';  //'1' == symbol, char symbol->
const char TESTER_BUTTON = '2';  // '1' == symbol, int

const int ANSWER_OUTPUT_FAIL = -10; // дл€ ошибки в answer_output()
const double BORDER = 0.0001;
const int NUMBER_OF_TEST = 9; // количество структур в TestBase_data

struct VariablesBase  {
    double a, b, c, solved_x1, solved_x2;
};

struct TestBase {
    double test_a, test_b, test_c, expected_x1, expected_x2;
    int expected_res;
};

int solve_square(double a, double b, double c, double* solved_x1, double* solved_x2);
int input_and_ans();
int is_close(double a, double b);
int answer_output(int res, double solved_x1, double solved_x2);
void RT_tester();
void clean_input();
void TestBase_data(int number_of_test, struct TestBase * return_TestBase_data);
int solve_linear(double b, double c, double * linear_x);
int confirm();
int do_check_symbol(char check_symbol);

int main() { // цикл на повторение программы

    printf("#################################  SQUARE EQUATION SOLVER  #################################\n\n");
    printf("%c - решить квадратное уравнение, %c - начать тестировку, люба€ друга€ клавиша - выход.\n\n", SOLVER_BUTTON, TESTER_BUTTON);
    int input_button = getche();
    printf("\n");

    while (true){
        printf("\n");
        if (input_button == SOLVER_BUTTON) {
            int input_test = input_and_ans();

            switch(input_test) {
                case true:
                    break;
                case ANSWER_OUTPUT_FAIL:
                    return 1;
                default:
                    printf("some problems with switch in main with solver\n");
                    return 1;
            }
        }
        else if (input_button == TESTER_BUTTON) {
            if (confirm()){
                printf("\n");
                RT_tester();
            }
        }
        else {
            if (confirm()) {
                break;
            }
        }
        printf("\n≈щЄ раз? 1 - решить квадратное уравнение, 2 - начать тестировку, люба€ друга€ клавиша - выход.\n\n");
        input_button = getche();
        printf("\n");
    }
    printf("\nЌу и ладно :(\n");
        return 0;
}

//#################################################################################################################//
//#################################################### SOLVER #####################################################//
//#################################################################################################################//

int input_and_ans() { // ввод и его проверка + вызов вывода ответа

    struct VariablesBase variables {NAN, NAN, NAN, NAN, NAN};

    printf("¬ведите значени€ a, b, c.\n\n");
    char check_symbol = 0;

    if (scanf("%lg %lg %lg%c", &(variables.a), &(variables.b), &(variables.c), &check_symbol) == 4 && do_check_symbol(check_symbol)) { // правильный ввод

        int res = solve_square(variables.a, variables.b, variables.c, &variables.solved_x1, &variables.solved_x2);
        printf("\n");
        answer_output(res, variables.solved_x1, variables.solved_x2);
    }
    else {  // неправильный ввод

        printf("\nЌеправильный ввод.\n");

        //while (getchar() != '\n') {}  // skip input
    }
    clean_input();
    return true;
}

int answer_output(int res, double solved_x1, double solved_x2) {  // вывод ответа

    switch(res) {
        case ZERO_ROOTS:
            printf("Ќет решений.\n");
            return true;
        case ONE_ROOT:
            printf("1 решение - х = %lg.\n", solved_x1);
            return true;
        case TWO_ROOTS:
            printf("2 решени€ - х1 = %lg и х2 = %lg.\n", solved_x1, solved_x2);
            return true;
        case INFINITY_ROOTS:
            printf("Ѕесконечно много решений.\n");
            return true;
        default:
            printf("some problems with switch in main with answer_output.\n");
            return ANSWER_OUTPUT_FAIL;
    }
}

//#################################################################################################################//
//################################################ KERNEL #########################################################//
//#################################################################################################################//

int solve_square(double a, double b, double c, double* solved_x1, double* solved_x2) {  // считает квадратное уравнение

    assert(solved_x1);
    assert(solved_x2);

    if (is_close(a, 0) == EQUAL) {
        double linear_x = NAN;

        int linear_ans = solve_linear(b, c, &linear_x);
        *solved_x1 = *solved_x2 = linear_x;

        return linear_ans;
    }

    else {
        double dscr = b*b - 4*a*c;

        if (dscr < -BORDER) {
            return ZERO_ROOTS;
        }
        else if (is_close(dscr, 0) == EQUAL) {
            double square_x_b4_check = *solved_x1 = *solved_x2 = (-b) / (2*a);

            if (is_close(square_x_b4_check, 0) == EQUAL) {
                *solved_x1 = *solved_x2 = 0;
            }
            return ONE_ROOT;
        }
        else {
            double double_a = 2*a;
            double sqrt_dscr = sqrt(dscr);
            double b_div_double_a = b / double_a;
            double sqrt_dscr_div_double_a = sqrt_dscr / double_a;

            *solved_x1 = -b_div_double_a - sqrt_dscr_div_double_a;
            *solved_x2 = -b_div_double_a + sqrt_dscr_div_double_a;
            return TWO_ROOTS;
        }
    }
}

int solve_linear(double b, double c, double * linear_x) { // считает линейное уравнение
    assert(linear_x);

    if (is_close(b, 0) == EQUAL) {
        if (is_close(c, 0) == EQUAL) {
            return INFINITY_ROOTS;
        }
        else {
            return ZERO_ROOTS;
        }
    }
    else {
        double linear_x_b4_check = *linear_x = (-c) / b;
        if (is_close(linear_x_b4_check, 0) == EQUAL) {
            *linear_x = 0;
        }
        return ONE_ROOT;
    }
}

int is_close(double float_1, double float_2) { // сравнение числа с границей
                                               // TOdo; COOL Double function 1 0 -1
    if (fabs(float_1 - float_2) < BORDER) {
        return EQUAL;
    }
    else if (float_1 > float_2) {
        return BIGGER_1;
    }
    else {
        return BIGGER_2;
    }

}

void clean_input() { // скип бессмысленного ввода

    while (getchar() != '\n') {}
}

//#################################################################################################################//
//################################################# TESTER ########################################################//
//#################################################################################################################//

void TestBase_data(int number_of_test, struct TestBase * return_TestBase_data) { // хранилище значений дл€ теста
    assert(return_TestBase_data);

    struct TestBase test[] = {

        // test_a, test_b, test_c, expected_x1, expected_x2, expected_res

        {1,     2,    1,     -1,        -1,       ONE_ROOT},
        {0,     0,    0,     NAN,       NAN,      INFINITY_ROOTS},
        {0,     2.5,  -12.5, 5,         5,        ONE_ROOT},
        {1,     2,    3,     NAN,       NAN,      ZERO_ROOTS},
        {1,     0,    0,     0,         0,        ONE_ROOT},
        {2.4,   25.8, -79.5, 2.5,       -13.25,   TWO_ROOTS},
        {46532, 46,   -6461, -0.373121, 0.372133, TWO_ROOTS},
        {1,     0,    0,     0,         0,        ONE_ROOT},
        {0,     2,    0,     0,         0,        ONE_ROOT}

    };

    *return_TestBase_data = test[number_of_test];
}

void RT_tester() { // тестировщик



    int number_of_test = 1;
    struct TestBase get_TestBase_data = {};

    while (number_of_test != NUMBER_OF_TEST + 1) {
        double solved_x1 = NAN, solved_x2 = NAN;
        
        TestBase_data(number_of_test - 1, &get_TestBase_data);
        
        int res = solve_square(get_TestBase_data.test_a, get_TestBase_data.test_b, get_TestBase_data.test_c, &solved_x1, &solved_x2);

        if (is_close(get_TestBase_data.expected_x1, get_TestBase_data.expected_x2) == BIGGER_1) { // сортировка эталонных корней
            double temp = get_TestBase_data.expected_x1;
            
            get_TestBase_data.expected_x1 = get_TestBase_data.expected_x2;
            get_TestBase_data.expected_x2 = temp;
        }

        if (is_close(res, get_TestBase_data.expected_res) == EQUAL &&   // равенство количества корней
           (is_close(solved_x1, get_TestBase_data.expected_x1) == EQUAL || (isnan(solved_x1) && isnan(get_TestBase_data.expected_x1)))  && // равенство первых корней
           (is_close(solved_x2, get_TestBase_data.expected_x2) == EQUAL || (isnan(solved_x2) && isnan(get_TestBase_data.expected_x2)))) {  // равенство вторых корней

            printf("Test %d: OK.\n", number_of_test);
        }
        else {
            printf("Err Test %d: a = %lg, b = %lg, c = %lg, Roots = %d, X1 = %lg, X2 = %lg.\n"
                   "Expected: Roots = %d, X1 = %lg, X2 = %lg.\n",
                   number_of_test, get_TestBase_data.test_a, get_TestBase_data.test_b, get_TestBase_data.test_c, res, solved_x1, solved_x2,
                   get_TestBase_data.expected_res, get_TestBase_data.expected_x1, get_TestBase_data.expected_x2);
        }
        
        ++number_of_test;
        printf("\n");
    }
}

//#################################################################################################################//
//################################################# INPUT CHECKING ################################################//
//#################################################################################################################//

int confirm() {
    printf("¬ы уверены? %c - да, люба€ друга€ клавиша - нет.\n\n", CONFIRM);
    int confirmation_button = getche();
    printf("\n");

    if (confirmation_button == CONFIRM) {
        return 1;
    }
    return 0;
}


int do_check_symbol(char check_symbol) {
    if (check_symbol == EOF || check_symbol =='\n' || check_symbol ==' ') {
        ungetc(check_symbol, stdin);
        return 1;
    }
    return 0;
}
